<?xml version="1.0"?>
<doc>
    <assembly>
        <name>PaintDotNet.ComponentModel</name>
    </assembly>
    <members>
        <member name="T:PaintDotNet.ComponentModel.ByRefHandle`1">
            <summary>
            Similar to RefHandle, but is a ref struct. It also keeps an additional object ref for keepalives purposes.
            </summary>
        </member>
        <member name="T:PaintDotNet.ComponentModel.IInternalObjectRefWrapper">
            <summary>
            Implemented by a class that is wrapping an IObjectRef object, such that
            internal code can still get access to the wrapped object. This permits
            slicing off interfaces for public APIs (e.g. plugins), but maintaining
            the interfaces for internal APIs.
            </summary>
        </member>
        <member name="T:PaintDotNet.ComponentModel.IObjectRef">
            <summary>
            An individually tracked reference to an underlying object instance. This is similar to IUnknown in COM.
            </summary>
        </member>
        <member name="M:PaintDotNet.ComponentModel.IObjectRef.TryCreateRef(System.Type,PaintDotNet.ComponentModel.IObjectRef@)">
            <summary>
            Checks to see if the given interface is supported by this object, and if so creates that wrapper
            and provides it to you. This adds 1 to the reference count of the underlying object. To decrement
            the reference count, dispose the wrapper provided by this method or permit it to be garbage
            collected. When the reference count reaches 0, the object will be disposed.
            </summary>
            <param name="interfaceType">
            The interface <see cref="T:System.Type"/> to query for. This must derive from <see cref="T:PaintDotNet.ComponentModel.IObjectRef"/>.
            </param>
            <param name="newObjectRef">
            On successful return, this holds the new object ref.
            </param>
            <returns>
            <b>true</b> if the interface is supported, in which case <paramref name="newObjectRef"/> will be
            the new ref. It will be castable to <paramref name="interfaceType"/>, and should be disposed
            (by calling <see cref="M:System.IDisposable.Dispose"/>) when the caller is finished using it. Not disposing
            it is also safe, as the GC will handle it, but performance may be impacted.<br/>
            <b>false</b> if the interface is not supported, in which case <paramref name="newObjectRef"/> will
            be null.<br/>
            <b>null</b> if the existing ref is disposed.<br/>
            It is always safe to call this method.
            </returns>
            <remarks>
            The wrapper that is returned refers to the same underlying object (COM or managed). This method
            is provided so that you can scope or protect references. This method must always return a new
            object; reference counted managed implementations are not allowed.
            </remarks>
        </member>
        <member name="T:PaintDotNet.ComponentModel.IObjectRefProxy">
            <summary>
            Implemented by an IObjectRef that serves as a separately tracked reference and that forwards all requests onto the inner ref. 
            </summary>
            <remarks>
            TryCreateRef() requests are always forwarded to the innermost ref.
            Although this interface derives from IObjectRef, it cannot be retrieved with TryCreateRef().
            This interface must only be implemented by wrappers/proxies.
            </remarks>
        </member>
        <member name="P:PaintDotNet.ComponentModel.IObjectRefProxy.InnerRef">
            <summary>
            Gets the IObjectRef that this proxy forwards its requests to.
            </summary>
        </member>
        <member name="T:PaintDotNet.ComponentModel.IRefCountedObject">
            <summary>
            Provides support for internal implementations of IObjectRef that support referencing counting.
            </summary>
            <remarks>
            This interface exists for performance optimization purposes.
            </remarks>
        </member>
        <member name="M:PaintDotNet.ComponentModel.IRefCountedObject.TryAddRef(System.Int32@)">
            <summary>
            Adds 1 to the ref count for the IObjectRef.
            </summary>
            <returns>
            true if the ref count was increased, in which case newRefCount will equal the new ref count.
            false if the object is already disposed.
            </returns>
        </member>
        <member name="M:PaintDotNet.ComponentModel.IRefCountedObject.ReleaseRef(System.Boolean)">
            <summary>
            Subtracts 1 from the ref count.
            </summary>
            <exception cref="T:System.ObjectDisposedException">The object is already disposed.</exception>
            <param name="disposing">
            Indicates whether the caller is being finalized (false) or not. Only pass false 
            if you are calling this method during your finalizer.
            </param>
            <returns>The new ref count. 0 indicates that the object is now disposed.</returns>
        </member>
        <member name="T:PaintDotNet.ComponentModel.IRef`1">
            <summary>
            Implemented by a class or struct that provides access to an object reference
            and provides a lifetime management or ownership policy.
            </summary>
        </member>
        <member name="T:PaintDotNet.ComponentModel.ISharedRef`1">
            <summary>
            Similar to C++'s std::shared_ptr, this owns an object and manages its lifetime.
            The object will be disposed once the reference count of the ISharedRef is zero.
            This can be useful for solving lifetime management issues without implementing
            IObjectRef on the class itself.
            </summary>
        </member>
        <member name="M:PaintDotNet.ComponentModel.ObjectRefExtensions.TryCastOrCreateRef``1(PaintDotNet.ComponentModel.IObjectRef)">
            <summary>
            Tries to cast the given IObjectRef object to the requested type. 
            If that is not successful, then tries to create a new ref of the reqested type.
            Returns null if neither of those is successful.
            </summary>
            <remarks>
            Depending on the outcome, the ref may or may not need to be disposed. The caller 
            should always dispose the RefHandle, which will take care of this difference.
            </remarks>
        </member>
        <member name="M:PaintDotNet.ComponentModel.ObjectRefExtensions.CastOrTransferRef``1(PaintDotNet.ComponentModel.IObjectRef)">
            <summary>
            Tries to use a simple cast, and if that fails then a ref is created and the original ref is disposed.
            </summary>
            <exception cref="T:PaintDotNet.ComponentModel.InterfaceNotSupportedException">if objectRef does not support the requested interface</exception>
            <remarks>
            Casting is much faster than calling CreateRef(), but is not always an appropriate method for acquiring
            the desired interface. Casting to a derived interface type may sometimes work, but it is much better
            to use this method to ensure you have the type that you want.
            </remarks>
        </member>
        <member name="M:PaintDotNet.ComponentModel.ObjectRefProxy.Dispose(System.Boolean)">
            <summary>
            Implemented by a derived class to perform additional cleanup. This is called before the inner ref is released,
            so it is still safe to make calls to it (if disposing is true).
            </summary>
            <param name="disposing">
            true if the object is being destroyed due to a call to Dispose().
            false if the object is being destroyed due to finalization.
            </param>
        </member>
        <member name="F:PaintDotNet.ComponentModel.ObjectRefProxyOptions.Default">
            <summary>
            Specifies default behavior for the proxy. If the object given to the constructor
            is a proxy, then it will be unwrapped. The proxy will serve as a new reference
            by using IRefCountedObject::TryAddRef() or IObjectRef::TryCreateRef() at construction
            time, and IRefCountedObject::ReleaseRef() or IDisposable::Dispose() at destruction
            time.
            </summary>
        </member>
        <member name="F:PaintDotNet.ComponentModel.ObjectRefProxyOptions.DoNotCreateRef">
            <summary>
            The proxy will not create a new reference. This can be used to create something
            analagous to a "weak" reference. The proxy will permit access to the inner object,
            potentially via a different interface than the inner ref, but will not prevent it
            from being destroyed.
            </summary>
        </member>
        <member name="F:PaintDotNet.ComponentModel.ObjectRefProxyOptions.DisposeInnerRef">
            <summary>
            The proxy will release the inner reference at destruction time by calling
            IDisposable::Dispose(). It will not call IRefTrackedObject::ReleaseRef().
            </summary>
        </member>
        <member name="F:PaintDotNet.ComponentModel.ObjectRefProxyOptions.ProhibitDispose">
            <summary>
            If Dispose() is called on the proxy, then an exception will be thrown.
            </summary>
            <remarks>
            This takes precedences over the IgnoreDispose flag.
            </remarks>
        </member>
        <member name="F:PaintDotNet.ComponentModel.ObjectRefProxyOptions.IgnoreDispose">
            <summary>
            If Dispose() is called on the proxy, nothing will happen. This object can only be
            cleaned up by the garbage collector when there are no live references to it.
            </summary>
            <remarks>
            This flag is ignore if used along with the ProhibitDispose flag.
            </remarks>
        </member>
        <member name="M:PaintDotNet.ComponentModel.RefHandleExtensions.DetachAsUniqueRef``1(PaintDotNet.ComponentModel.RefHandle{``0}@)">
            <summary>
            Detaches the ref. If the ref is not owned by the handle, a new ref is created.
            </summary>
            <returns>An IObjectRef that the caller is responsible for disposing.</returns>
        </member>
        <member name="T:PaintDotNet.ComponentModel.RefHandle`1">
            <summary>
            Encapsulates a ref and whether it needs to be disposed or not. When the ref is "owned"
            (OwnsRef is true) the handle behaves like C++'s unique_ptr, which means the ref will be
            disposed when the handle is disposed. When the ref is not owned (OwnsRef is false), the
            handle behaves like C++'s weak_ptr, which means the ref will not be disposed when the
            handle is disposed.
            </summary>
            <remarks>
            This struct is typically returned from methods that return a ref that the caller may or
            may not need to dispose, depending on circumstance. By returning this struct, the 
            caller can unconditionally call Dispose() or employ a using-block.
            </remarks>
        </member>
        <member name="P:PaintDotNet.ComponentModel.RefHandle`1.OwnsRef">
            <summary>
            Gets whether this handle owns the ref or not. If true, then disposing the handle
            will also dispose the Ref.
            </summary>
        </member>
        <member name="M:PaintDotNet.ComponentModel.RefHandle`1.Dispose(System.Boolean)">
            <summary>
            Disposes this ref handle if the caller is not being finalized.
            </summary>
            <param name="callerIsNotFinalizing">
            Whether or not the caller is in their finalizer. Pass in the value of 'disposing' 
            from the Dispose(bool) method. Otherwise, just call Dispose().
            If this value is false (which will be the case when Dispose(bool) is called from
            a finalizer), then the ref handle will only set the Ref to null.
            </param>
            <remarks>
            This overload of Dispose() should only be used from a Dispose(bool) method. It is
            generally not safe to call Dispose() on objects from finalizers, and this method
            helps manage that.
            </remarks>
        </member>
        <member name="M:PaintDotNet.ComponentModel.RefHandle`1.Detach">
            <summary>
            Detaches the ref from this handle. Ownership information is lost.
            </summary>
        </member>
        <member name="M:PaintDotNet.ComponentModel.RefHandle`1.Cast``1">
            <summary>
            Casts the ref to the requested type, detaches the ref from this handle,
            and transfers ownership to a new handle.
            </summary>
        </member>
        <member name="T:PaintDotNet.ComponentModel.RefTrackedObject">
            <summary>
            Provides a base implementation for a managed IObjectRef that tracks its references.
            </summary>
            <remarks>
            References are divided into two categories: primary, and secondary. 
            Secondary references are those which are retrieved via TryCreateRef.
            The primary reference is the object instance itself. Calling Dispose() will
            only decrement the reference count the first time it's called. 
            Both reference types are counted in the 'refCount' field, and are treated
            equally when deciding when to finally execute the inner Dispose() method.
            </remarks>
        </member>
        <member name="T:PaintDotNet.Disposable">
            <summary>
            Provides a standard implementation of IDisposable and IIsDisposed.
            </summary>
        </member>
        <member name="M:PaintDotNet.Disposable.FromAction(System.String,System.Action,PaintDotNet.DisposableActionCompletionStrategy)">
            <summary>
            Returns an IDisposable that calls the given action when its Dispose() method is called.
            </summary>
            <remarks>
            The action is not called if the IDisposable is finalized. Use FromCallback() if you need
            the action to be called from the finalizer.
            </remarks>
        </member>
        <member name="M:PaintDotNet.Disposable.StructuredUsing``1(``0,System.Action{``0})">
            <summary>
            Similar to a using() block except that if an exception is thrown by the auto-object's
            Dispose() method it will be aggregated with any exception that came out of the using block.
            </summary>
        </member>
        <member name="T:PaintDotNet.IInternalImpl">
            <summary>
            Implemented by interfaces that may be consumed publicly but only implemented internally.
            </summary>
        </member>
    </members>
</doc>
