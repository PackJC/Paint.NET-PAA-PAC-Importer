<?xml version="1.0"?>
<doc>
    <assembly>
        <name>PaintDotNet.Framework</name>
    </assembly>
    <members>
        <member name="M:PaintDotNet.Controls.Direct2DButtonBase.PerformVisualStateChange(System.Boolean)">
            <summary>
            If the visual state should be updated, this will update and repaint things.
            </summary>
            <param name="immediateRefresh">true if the control should immediately repaint the ui. Otherwise just invalidate and repaint asap</param>
        </member>
        <member name="T:PaintDotNet.Controls.Direct2DControl">
            <summary>
            Provides a base WinForms control that renders using Direct2D.
            </summary>
        </member>
        <member name="P:PaintDotNet.Controls.Direct2DControl.UseBackColor">
            <summary>
            Gets or sets a flag specifying if the <see cref="T:PaintDotNet.Direct2D1.IDeviceContext"/> is automatically cleared
            using <see cref="P:System.Windows.Forms.Control.BackColor"/>. The default value is true.
            </summary>
        </member>
        <member name="P:PaintDotNet.Controls.Direct2DControl.HwndPresentOptions">
            <summary>
            Specifies the <see cref="T:PaintDotNet.Direct2D1.PresentOptions"/> when <see cref="P:PaintDotNet.Controls.Direct2DControl.HwndDeviceContextEnabled"/> is true.
            This has no effect when <see cref="P:PaintDotNet.Controls.Direct2DControl.HwndDeviceContextEnabled"/> is false.<br/>
            The default value specifies both <see cref="F:PaintDotNet.Direct2D1.PresentOptions.RetainContents"/> and <see cref="F:PaintDotNet.Direct2D1.PresentOptions.Immediately"/>.
            Removing the <see cref="F:PaintDotNet.Direct2D1.PresentOptions.Immediately"/> option will enable V-Sync.<br/>
            Removing the <see cref="F:PaintDotNet.Direct2D1.PresentOptions.RetainContents"/> option is not recommended, as it can cause rendering issues with some hardware such as NVIDIA Optimus.<br/>
            </summary>
        </member>
        <member name="P:PaintDotNet.Controls.Direct2DControl.HwndDeviceContextEnabled">
            <summary>
            Specifies whether to use an <see cref="T:PaintDotNet.Direct2D1.IHwndDeviceContext"/>. If false, <see cref="T:PaintDotNet.Direct2D1.IDCDeviceContext"/>
            will be used instead, which is more compatible in various contexts. Setting this to true is required
            in order to use hardware-accelerated rendering.<br/>
            The default value is true.
            </summary>
        </member>
        <member name="P:PaintDotNet.Controls.Direct2DControl.HwndAllowHardwareRendering">
            <summary>
            Specifies whether to allow hardware-accelerated rendering. This can be overridden by user-controlled
            app settings to force software rendering. Hardware-accelerated rendering is only supported if
            <see cref="P:PaintDotNet.Controls.Direct2DControl.HwndDeviceContextEnabled"/> is true. Otherwise, software rendering will be used.<br/>
            The default value is true.
            </summary>
        </member>
        <member name="P:PaintDotNet.Controls.Direct2DControl.AllowHardwareRendering">
            <summary>
            Specifies whether to allow hardware-accelerated rendering. This can be overridden by user-controlled
            app settings to force software rendering, and may be disabled for other reasons as well.<br/>
            The default value is true. For small controls, like buttons or text labels, it is recommended to set
            this to false. Hardware accelerated rendering should typically be reserved for larger controls,
            such as the main control or canvas contained in a top-level window (Form).
            </summary>
        </member>
        <member name="M:PaintDotNet.Controls.Direct2DControl.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:PaintDotNet.Controls.Direct2DControl"/> class. A new Direct2D factory
            is created, providing an isolated resource domain for this control instance.
            </summary>
        </member>
        <member name="M:PaintDotNet.Controls.Direct2DControl.#ctor(PaintDotNet.Direct2D1.IDirect2DFactory)">
            <summary>
            Initializes a new instance of the <see cref="T:PaintDotNet.Controls.Direct2DControl"/>, using the given Direct2D factory.
            </summary>
            <param name="d2dFactory">The factory to use.</param>
            <remarks>
            If you are implementing a GpuEffect with a custom EffectConfigForm that uses <see cref="T:PaintDotNet.Controls.Direct2DControl"/>(s),
            it is not a good idea to share the <see cref="T:PaintDotNet.Direct2D1.IDirect2DFactory"/> between the GpuEffect and the control.
            This will cause performance issues because the factory is also a lock, and all calls into the factory or
            any objects created from it will enter that lock. So if the GpuEffect is rendering, it will stall the UI
            thread and make it not as responsive.<br/>
            <br/>
            However, if you have multiple <see cref="T:PaintDotNet.Controls.Direct2DControl"/>s then it is a good idea to share one factory
            between them all (just not the one that the GpuEffect is using!). This will save memory, and also permits
            sharing Direct2D objects amongst the controls.
            </remarks>
        </member>
        <member name="P:PaintDotNet.Controls.Direct2DControl.DoubleBufferedGdiPaint">
            <summary>
            This property is not applicable to this class.
            </summary>
        </member>
        <member name="T:PaintDotNet.Controls.Direct2DControlImpl">
            <summary>
            Provides the logic for handling Direct2D painting for a control which is already
            using a GdiControlImpl (e.g. GdiControl).
            </summary>
        </member>
        <member name="P:PaintDotNet.Controls.Direct2DPictureBox.SizeMode">
            <summary>
            Indicates how the bitmap is displayed.
            </summary>
        </member>
        <member name="P:PaintDotNet.Controls.Direct2DPictureBox.BitmapInterpolationMode">
            <summary>
            Indicates the interpolation mode to use for drawing the bitmap.
            </summary>
        </member>
        <member name="M:PaintDotNet.Controls.Direct2DPictureBox.InvalidateBitmap">
            <summary>
            This method should be called if the contents of the <see cref="P:PaintDotNet.Controls.Direct2DPictureBox.Bitmap"/> change.
            This will cause the bitmap to be re-copied to the GPU.
            </summary>
        </member>
        <member name="F:PaintDotNet.Controls.Direct2DPictureBoxSizeMode.Normal">
            <summary>
            The bitmap is placed in the upper-left corner of the <see cref="T:PaintDotNet.Controls.Direct2DPictureBox"/>. The
            bitmap is clipped if it is larger than the <see cref="T:PaintDotNet.Controls.Direct2DPictureBox"/> it is contained
            in.
            </summary>
        </member>
        <member name="F:PaintDotNet.Controls.Direct2DPictureBoxSizeMode.StretchBitmap">
            <summary>
            The bitmap within the <see cref="T:PaintDotNet.Controls.Direct2DPictureBox"/> is stretched or shrunk to fit the size
            of the <see cref="T:PaintDotNet.Controls.Direct2DPictureBox"/>.
            </summary>
        </member>
        <member name="F:PaintDotNet.Controls.Direct2DPictureBoxSizeMode.Zoom">
            <summary>
            The size of the bitmap is increased or decreased maintaining the size ratio.
            </summary>
        </member>
        <member name="P:PaintDotNet.Controls.Direct2DPointerControl.PointerScreenPosition">
            <summary>
            Gets the latest pointer position in screen coordinates. If the pointer is not within the client region, this will return null.
            </summary>
        </member>
        <member name="T:PaintDotNet.Controls.Direct2DPushButtonBase">
            <summary>
            This class provides the logic for handling input and managing rendering
            states for a typical button type control. Just provide the rendering code!
            </summary>
        </member>
        <member name="M:PaintDotNet.Controls.PdnButtonBase.PerformVisualStateChange(System.Boolean)">
            <summary>
            If the visual state should be updated, this will update and repaint things.
            </summary>
            <param name="immediateRefresh">true if the control should immediately repaint the ui. Otherwise just invalidate and repaint asap</param>
        </member>
        <member name="P:PaintDotNet.Controls.PdnNumericSpin.UserEdit">
            <summary>
            Gets or sets a value indicating whether a value has been entered by the user.
            </summary>
        </member>
        <member name="P:PaintDotNet.Controls.PdnNumericSpin.ChangingText">
            <summary>
            Gets or sets a value indicating whether the text property is being changed internally by its parent class.
            </summary>
        </member>
        <member name="T:PaintDotNet.Controls.PdnNumericUpDown">
            <summary>
            This class implements some common things on top of the regular NumericUpDown class.
            </summary>
        </member>
        <member name="T:PaintDotNet.Controls.PdnPushButtonBase">
            <summary>
            This class provides the logic for handling input and managing rendering
            states for a typical button type control. Just provide the rendering code!
            </summary>
        </member>
        <member name="P:PaintDotNet.Controls.PointerControl.PointerScreenPosition">
            <summary>
            Gets the latest pointer position in screen coordinates. If the pointer is not within the client region, this will return null.
            </summary>
        </member>
        <member name="M:PaintDotNet.Direct2D1.BufferedDeviceContext.CopyFromTargetToBuffer">
            <summary>
            Copies from the target bitmap to the buffer bitmap. RenderSync and BufferSync must be entered, in that order.
            </summary>
        </member>
        <member name="M:PaintDotNet.Direct2D1.BufferedDeviceContext.CopyFromTargetToBuffer(PaintDotNet.Rendering.SizeInt32)">
            <summary>
            Copies from the target bitmap to the buffer bitmap. RenderSync and BufferSync must be entered, in that order.
            </summary>
        </member>
        <member name="M:PaintDotNet.Direct2D1.BufferedDeviceContext.CopyFromBuffer``1(PaintDotNet.RegionPtr{``0})">
            <summary>
            Copies from the buffer bitmap to the dst. BufferSync must be entered.
            </summary>
        </member>
        <member name="M:PaintDotNet.Direct2D1.BufferedDeviceContext.CopyFromBuffer(PaintDotNet.Imaging.PixelFormat@,System.Void*,System.Int32,System.Int32,System.Int32)">
            <summary>
            Copies from the buffer bitmap to the dst. BufferSync must be entered.
            </summary>
        </member>
        <member name="P:PaintDotNet.Direct2D1.IDeviceContextHandler.TargetBitmap">
            <summary>
            The bitmap used as the target for the device context. This bitmap will have BitmapOptions.Target.
            It may be copied from, and used in a call to IDeviceContext.DrawBitmap(), but it may not not be
            mapped for CPU reading.
            </summary>
            <remarks>
            This is not necessarily the same object returned by IDeviceContext.GetTarget(), but it will reference
            the same memory. (for WARP, a workaround is needed)
            </remarks>
        </member>
        <member name="M:PaintDotNet.Direct2D1.IDirect2DDrawer.BeforeDraw(PaintDotNet.Direct2D1.IDeviceContext,PaintDotNet.Rendering.RectInt32)">
            <summary>
            Called before Draw(), with the entire render rectangle.
            This method is called while the render lock is held, so there's no need to perform your own synchronization.
            </summary>
        </member>
        <member name="M:PaintDotNet.Direct2D1.IDirect2DDrawer.Draw(PaintDotNet.Direct2D1.IDeviceContext,PaintDotNet.Rendering.RectInt32)">
            <summary>
            Called to perform drawing. The clip rectangle may be less than the entire render rectangle, depending
            on the the target size.
            This method is called while the render lock is held, so there's no need to perform your own synchronization.
            </summary>
        </member>
        <member name="M:PaintDotNet.Direct2D1.IDirect2DDrawerBase.InvalidateDeviceResources">
            <summary>
            Called when the drawer should release its device resources, usually when the device context is
            being recreated or destroyed.
            This method is called while the render lock is held, so there's no need to perform your own synchronization.
            </summary>
        </member>
        <member name="M:PaintDotNet.Direct2D1.IDirect2DDrawerBase.SetDeviceContext(PaintDotNet.Direct2D1.IDeviceContext)">
            <summary>
            Called when a new device context has been created, and before any drawing methods are called.
            Will not be called unless a draw call is about to happen.
            Will not be called again unless InvalidateDeviceResources() is also called.
            This method is called while the render lock is held, so there's no need to perform your own synchronization.
            </summary>
        </member>
        <member name="M:PaintDotNet.Direct2D1.IDirect2DDrawerBase.AfterDraw(PaintDotNet.Direct2D1.IDeviceContext,PaintDotNet.Rendering.RectInt32)">
            <summary>
            Called after all Draw() calls have completed.
            This method is called while the render lock is held, so there's no need to perform your own synchronization.
            </summary>
        </member>
        <member name="M:PaintDotNet.Direct2D1.IDirect2DDrawer`1.BeforeDraw(PaintDotNet.Direct2D1.IDeviceContext,PaintDotNet.Rendering.RectInt32,`0)">
            <summary>
            Called before Draw(), with the entire render rectangle.
            This method is called while the render lock is held, so there's no need to perform your own synchronization.
            </summary>
        </member>
        <member name="M:PaintDotNet.Direct2D1.IDirect2DDrawer`1.Draw(PaintDotNet.Direct2D1.IDeviceContext,PaintDotNet.Rendering.RectInt32,`0)">
            <summary>
            Called to perform drawing. The clip rectangle may be less than the entire render rectangle, depending
            on the the target size.
            This method is called while the render lock is held, so there's no need to perform your own synchronization.
            </summary>
        </member>
        <member name="P:PaintDotNet.Direct2D1.MultisampleMapRenderer.Props.EdgeMode">
            <summary>
            <inheritdoc cref="P:PaintDotNet.Direct2D1.SampleMapRenderer.Props.EdgeMode"/>
            </summary>
        </member>
        <member name="P:PaintDotNet.Direct2D1.MultisampleMapRenderer.Props.SamplingMode">
            <summary>
            <inheritdoc cref="P:PaintDotNet.Direct2D1.SampleMapRenderer.Props.SamplingMode"/>
            </summary>
        </member>
        <member name="P:PaintDotNet.Direct2D1.MultisampleMapRenderer.MaxSampleOffset">
            <summary>
            <inheritdoc cref="P:PaintDotNet.Direct2D1.SampleMapRenderer.MaxSampleOffset"/>
            </summary>
        </member>
        <member name="T:PaintDotNet.Direct2D1.SampleMapEdgeMode">
            <summary>
            Specifies how to treat out-of-bounds sampling coordinates. 
            </summary>
        </member>
        <member name="F:PaintDotNet.Direct2D1.SampleMapEdgeMode.Clamp">
            <summary>
            Sample coordinates that are out-of-bounds will be clamped to the edge of the input rectangle.
            </summary>
        </member>
        <member name="F:PaintDotNet.Direct2D1.SampleMapEdgeMode.Wrap">
            <summary>
            Sample coordinates that are out-of-bounds will be wrapped around to the other side of the input rectangle.
            </summary>
        </member>
        <member name="F:PaintDotNet.Direct2D1.SampleMapEdgeMode.Mirror">
            <summary>
            Sample coordinates that are out-of-bounds will be mirrored back inside of the input rectangle, as if the
            edges were mirrors.
            </summary>
        </member>
        <member name="F:PaintDotNet.Direct2D1.SampleMapEdgeMode.Transparent">
            <summary>
            Sample coordinates that are out-of-bounds of the input rectangle will be emitted as transparent.
            </summary>
        </member>
        <member name="T:PaintDotNet.Direct2D1.SampleMapRenderer">
            <summary>
            Transforms an image with a sample map. A sample map is an image (IDeviceImage) where the [x,y] (or [r,g]) component of
            each pixel is used for reading a sample from the input image. The w (or a) component is used as an alpha value
            that the sampled pixel is multiplied by (it should usually just be 1).<br/>
            <br/>
            Multiple sample maps can be specified, and the outputs will be averaged together. This can be used to implement
            multisample sub-pixel antialiasing.
            </summary>
            <remarks>
            <b>Note:</b> The device context must be rendering to a target that uses Float32 buffer precision. Otherwise the output will not be correct.
            </remarks>
        </member>
        <member name="P:PaintDotNet.Direct2D1.SampleMapRenderer.Props.EdgeMode">
            <summary>
            Gets or sets how sample coordinates outside of InputRect are treated.
            </summary>
        </member>
        <member name="P:PaintDotNet.Direct2D1.SampleMapRenderer.Props.SamplingMode">
            <summary>
            Gets or sets the sampling mode when reading from the input image. The default is SampleMapSamplingMode.Linear.
            </summary>
        </member>
        <member name="P:PaintDotNet.Direct2D1.SampleMapRenderer.MaxSampleOffset">
            <summary>
            Gets or sets the maximum offset that a sample will be from the scene position. This can be used to optimized
            rendering performance. The default value is [int.MaxValue, int.MaxValue], which is logically infinite.
            Setting this value too small can result in incorrect rendering.
            </summary>
        </member>
        <member name="P:PaintDotNet.Direct2D1.SampleMapRenderer.SampleMapCount">
            <summary>
            Gets or sets the number of sample maps.
            </summary>
            <remarks>
            The value must be 1 or more.<br/>
            This is a convenience property that will get <see cref="P:PaintDotNet.Direct2D1.DynamicImage.InputCount"/>-1, and set <see cref="P:PaintDotNet.Direct2D1.DynamicImage.InputCount"/>+1.
            </remarks>
        </member>
        <member name="T:PaintDotNet.Direct3D11.D3D11DeviceCache">
            <summary>
            Maintains a cache if ID3D11Device objects. This is necessary for UI elements (e.g. Direct2DControl) so that each
            one doesn't create a brand new device. Since the NVIDIA driver likes to create 1 thread per CPU core per
            ID3D11Device, this is an important memory usage optimization.
            </summary>
            <remarks>
            Note that ID3D11Devices are never released once they are in the cache. This should be fine for now since there's
            only a very small number of devices that will actually be created by UI elements.
            </remarks>
        </member>
        <member name="T:PaintDotNet.Gpu.GpuKeepAlive">
            <summary>
            The job of this class is to maintain a reference to an ID3D11Device corresponding to the current rendering device
            specified by AppSettings.Graphics.RenderingGpuChoice. On a system with hybrid graphics, like on a laptop where you
            have an Intel iGPU + NVIDIA dGPU, creating the ID3D11Device for the dGPU can incur a 1-2 second delay while the
            dGPU powers on. Maintaining an instance of the ID3D11Device for the dGPU prevents it from powering down and causing
            a 1-2 second mini-hang in the UI.
            </summary>
        </member>
        <member name="F:PaintDotNet.Gpu.GpuPerformanceClass.VeryLow">
            <summary>
            Indicates that quality settings should be reduced as much as possible and that the GPU
            is not powerful enough for interactive rendering.<br/>
            The Move Selected Pixels tool will default to an interpolation mode that uses the CPU
            without Direct2D.
            </summary>
            <remarks>
            This is used for WARP/CPU rendering, and for Intel HD/UHD iGPUs.
            </remarks>
        </member>
        <member name="F:PaintDotNet.Gpu.GpuPerformanceClass.Low">
            <summary>
            Indicates that quality settings should be reduced as much as possible, but that the GPU
            is either powerful enough for interactive rendering or at least as good as the CPU.<gr/>
            The Move Selected Pixels tool will default to an interpolation mode that uses the GPU
            via Direct2D.
            </summary>
            <remarks>
            This is used on ARM64, such as for the Surface Pro X, where the CPU is fairly weak and
            thus the GPU is still a better choice for interactive rendering (e.g. Move Selected
            Pixels).
            </remarks>
        </member>
        <member name="F:PaintDotNet.Gpu.GpuPerformanceClass.Good">
            <summary>
            Indicates that quality settings can be at standard levels. The GPU is a good choice for
            interactive rendering.
            </summary>
        </member>
        <member name="P:PaintDotNet.Imaging.ImageColorsAnalysis.LosslessPalette">
            <summary>
            If present, provides a palette that can be used to losslessly save the image with up to 256 colors.
            </summary>
            <remarks>
            If the palette has 256 colors or less and AlphaMixture is AllOpaque, saving losslessly at 8-bit is possible.<br/>
            If the palette has 256 colors or less and AlphaMixture is AllOpaqueOrTransparent, saving losslessly at 8-bit w/ 1 transparent color is possible.<br/>
            This palette will always have at least 1 opaque color, even if the image is comprised of all transparent pixels.
            </remarks>
        </member>
        <member name="T:PaintDotNet.Imaging.PaletteTable">
            <summary>
            Stores and provides access to a palette for indexed color formats. Ensures that the palette
            is well-formed. Up to 256 opaque colors, or up to 255 opaque + 1 transparent color in the
            last slot.
            </summary>
        </member>
        <member name="T:PaintDotNet.Imaging.Quantization.PaletteMap">
            <summary>
            Provides services for mapping arbitrary colors onto a fixed palette.
            </summary>
        </member>
        <member name="T:PaintDotNet.Imaging.Quantization.ProximityPaletteMap">
            <summary>
            This divides up the color space into 16x16x16 cubes (dependent on the precisionBits constant).
            For the center of each cube, the palette is copied and sorted with respect to distance from
            that center point.<br/>
            <br/>
            To query for any target point (color), the closest cube's proximity list is obtained and is
            searched for the closest point to the target. The math here gets a little tricky; we can detect
            when to stop searching based on when a point's ring is further away than the closest point that
            we've seen.<br/>
            <br/>
            A point's "ring" is the circle that contains a point and the cube's center point. The distance
            from the target point to that ring is<br/>
                <c>abs((distance from center to target) - (distance from center to point))</c><br/>
            <br/>
            The math is the same whether we're in 2D or 3D space, it only depends on the delta of the radii.
            https://www.varsitytutors.com/hotmath/hotmath_help/topics/shortest-distance-between-a-point-and-a-circle
            </summary>
        </member>
        <member name="M:PaintDotNet.Resources.CursorResource.TryLoadCustomCursor(System.String)">
            <summary>
            Loads a PNG cursor from PdnResources. The PNG must have an extra row and column for encoding
            the hotspot. The first non-transparent pixel encountered in the last row and last column will
            determine the X and Y hotspots, respectively.
            </summary>
            <param name="name">The resource name of the prefix, excluding the .PNG extension,
            and excluding the DPI specification. For example, to load "Cursors.MyToolCursor.96.png",
            specify "Cursors.MyToolCursor"</param>
            <returns>the cursor, or null if nothing can be found</returns>
        </member>
        <member name="P:PaintDotNet.Resources.ScaledResource`1.Resource">
            <summary>
            The resource. May be null.
            </summary>
        </member>
        <member name="P:PaintDotNet.Resources.ScaledResource`1.ScaleFactor">
            <summary>
            The UI scale that the image resource is targeted at. This is where 1px = 1px. At
            other UI scales, the resource should be drawn larger or smaller in order to compensate.
            </summary>
        </member>
        <member name="T:PaintDotNet.Shapes.DeclarativeShape">
            <summary>
            This is the base class containing common properties or metadata for declarative shapes,
            such as <see cref="T:PaintDotNet.Shapes.SimpleGeometryShape" />.
            </summary>
        </member>
        <member name="T:PaintDotNet.Shapes.SimpleGeometryShape">
            <summary>
            This is used in a XAML file to define the metadata and geometry for a Custom Shape plugin.
            </summary>
            <remarks>
            The XAML for the <see cref="P:PaintDotNet.Shapes.SimpleGeometryShape.Geometry"/> property is identical to that
            used for <a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.media.geometry">WPF geometry</a>.
            This include support for
            <a href="https://learn.microsoft.com/en-us/dotnet/desktop/wpf/graphics-multimedia/path-markup-syntax">Path markup syntax</a>.
            </remarks>
        </member>
    </members>
</doc>
